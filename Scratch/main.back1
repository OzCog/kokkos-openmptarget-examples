#include <Kokkos_Core.hpp>

using ExecSpace = Kokkos::DefaultExecutionSpace;
using TeamPolicy = Kokkos::TeamPolicy<ExecSpace>;
using member_type = TeamPolicy::member_type;
using ScratchIntView =
    Kokkos::View<int *, ExecSpace, Kokkos::MemoryTraits<Kokkos::Unmanaged>>;

#ifdef KOKKOS_ENABLE_OPENMPTARGET
inline void *get_dynamic_shared() { return NULL; }
#pragma omp begin declare variant match(device = {arch(nvptx64)})
extern "C" void *__kmpc_get_dynamic_shared();
inline void *get_dynamic_shared() { return __kmpc_get_dynamic_shared(); }
#pragma omp end declare variant
#endif

int main(int argc, char **argv) {
    Kokkos::initialize(argc, argv);
    {
        int x;
#ifdef KOKKOS_ENABLE_OPENMPTARGET
#pragma omp target parallel map(from : x)
        {
            int *buf = (int *)get_dynamic_shared();
#pragma omp barrier
            if (omp_get_thread_num() == 0) *buf = 1;
#pragma omp barrier
            if (omp_get_thread_num() == 1) x = *buf;
        }

        // CHECK: PASS
        if (x == 1) printf("PASS\n");
#endif


        const int team_size = 1;
        using ScratchSpace = ExecSpace::scratch_memory_space;
        using scratch_view_type = Kokkos::View<int *, ScratchSpace,
                             Kokkos::MemoryTraits<Kokkos::Unmanaged>>;

        size_t scratch_size = sizeof(int);

        Kokkos::TeamPolicy<ExecSpace> policy(1, team_size);
        Kokkos::View<int *, ExecSpace> v("v", 1);

        Kokkos::parallel_for(
            policy.set_scratch_size(0, Kokkos::PerTeam(scratch_size)),
            KOKKOS_LAMBDA(const member_type &team) {
                scratch_view_type scratch_view(team.team_scratch(0), team.team_size());

                if (team.team_rank() == 0) scratch_view(0) = 1;
            });
    }
    Kokkos::finalize();

    return 0;
}
