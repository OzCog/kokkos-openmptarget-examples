#include <Kokkos_Core.hpp>

using ExecSpace = Kokkos::DefaultExecutionSpace;
using TeamPolicy = Kokkos::TeamPolicy<ExecSpace>;
using member_type = TeamPolicy::member_type;
using ScratchSpace = ExecSpace::scratch_memory_space;
using scratch_view_type =
    Kokkos::View<int*, ScratchSpace, Kokkos::MemoryTraits<Kokkos::Unmanaged>>;

int main(int argc, char** argv) {
    Kokkos::initialize(argc, argv);
    {
        TeamPolicy policy(1, 32);
        size_t scratch_size = 2 * sizeof(int);
        Kokkos::View<int[2], ExecSpace> v("v");
        //        size_t scratch_size = sizeof(int);

        Kokkos::parallel_for(
            policy.set_scratch_size(0, Kokkos::PerTeam(scratch_size)),
            KOKKOS_LAMBDA(const member_type& team) {
                scratch_view_type scratch_view(team.team_scratch(0),
                                               team.team_size());

                if (team.team_rank() == 0) {
                    scratch_view(0) = 1;
                    scratch_view(1) = 2;

                    v(0) = scratch_view(0) + scratch_view(1);
                    v(1) = scratch_view(1) - scratch_view(0);
                }
            });
        Kokkos::fence();

        auto h_v = Kokkos::create_mirror_view_and_copy(Kokkos::HostSpace(), v);

        if (h_v(0) == 3 && h_v(1) == 1) printf("1orrectness passed \n");
        else
        {
            printf("Failed: v(0) = %d, expected 3\n",h_v(0));
            printf("Failed: v(1) = %d, expected 1\n",h_v(1));
        }
    }
    Kokkos::finalize();

    return 0;
}
