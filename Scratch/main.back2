#include <Kokkos_Core.hpp>

using ExecSpace = Kokkos::DefaultExecutionSpace;
using TeamPolicy = Kokkos::TeamPolicy<ExecSpace>;
using member_type = TeamPolicy::member_type;
using ScratchSpace = ExecSpace::scratch_memory_space;
using scratch_view_type =
    Kokkos::View<int*, ScratchSpace, Kokkos::MemoryTraits<Kokkos::Unmanaged>>;

template <class ExecutionSpace>
struct functor {
    KOKKOS_INLINE_FUNCTION
    void operator()(member_type team_member) const {
        size_t double_size = team_member.team_size() * sizeof(int);

        int* team_shared =
            (int*)team_member.team_shmem().get_shmem(double_size);

        if (team_member.team_rank() == 0) team_shared[0] = 1;
    }
};

int main(int argc, char** argv) {
    Kokkos::initialize(argc, argv);
    {
        TeamPolicy policy(1, 1);
#ifdef USE_SCRATCH_VIEW

//        size_t scratch_size = scratch_view_type::shmem_size(1);
        size_t scratch_size = 2*sizeof(int);

        Kokkos::parallel_for(
            policy.set_scratch_size(0, Kokkos::PerTeam(scratch_size)),
            KOKKOS_LAMBDA(const member_type& team) {
                scratch_view_type scratch_view(team.team_scratch(0),
                                               team.team_size());

                if (team.team_rank() == 0) scratch_view(0) = 1;
            });
#else

        size_t scratch_size = sizeof(int);
        Kokkos::parallel_for(
            policy.set_scratch_size(0, Kokkos::PerTeam(scratch_size)),
            functor<ExecSpace>());
#endif
        Kokkos::fence();
    }
    Kokkos::finalize();

    return 0;
}
